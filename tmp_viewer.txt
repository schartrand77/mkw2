"use client"
import { useEffect, useRef } from 'react'
import * as THREE from 'three'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'
import { STLLoader } from 'three/examples/jsm/loaders/STLLoader'

type Props = {
  src?: string
  srcs?: string[]
  className?: string
  height?: number
  autoRotate?: boolean
}

export default function ModelViewer({ src, srcs, className, height = 480, autoRotate = false }: Props) {
  const mountRef = useRef<HTMLDivElement | null>(null)

  useEffect(() => {
    if (!mountRef.current) return
    const width = mountRef.current.clientWidth
    const h = height
    const scene = new THREE.Scene()
    scene.background = new THREE.Color('#0b0f17')
    const camera = new THREE.PerspectiveCamera(45, width / h, 0.01, 1000)
    camera.position.set(2, 2, 2)
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true })
    renderer.setSize(width, h)
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    mountRef.current.appendChild(renderer.domElement)

    const light1 = new THREE.DirectionalLight(0xffffff, 1)
    light1.position.set(5, 10, 7.5)
    scene.add(light1)
    scene.add(new THREE.AmbientLight(0x888888))

    const controls = new OrbitControls(camera, renderer.domElement)
    controls.enableDamping = true
    controls.autoRotate = autoRotate
    controls.autoRotateSpeed = 1.0

    const loader = new STLLoader()
    const group = new THREE.Group()
    scene.add(group)

    const files = srcs && srcs.length ? srcs : (src ? [src] : [])
    const palette = [0x84cc16, 0xf59e0b, 0x3b82f6, 0x10b981, 0xef4444, 0xa855f7]
    let loaded = 0
    let overallBS: THREE.Sphere | null = null

    const onLoaded = () => {
      // Compute bounds in world space
      group.updateMatrixWorld(true)
      const box = new THREE.Box3().setFromObject(group)
      const size = new THREE.Vector3()
      const center = new THREE.Vector3()
      box.getSize(size)
      box.getCenter(center)
      // Move group so its center sits at the origin
      group.position.sub(center)
      group.updateMatrixWorld(true)
      // Scale to unit so it always fits
      const maxDim = Math.max(size.x, size.y, size.z)
      const radius = maxDim > 0 ? maxDim / 2 : 1
      const scale = radius > 0 ? 1 / radius : 1
      group.scale.setScalar(scale)
      group.updateMatrixWorld(true)
      // Frame the camera to comfortably view the object
      const fov = THREE.MathUtils.degToRad(camera.fov)
      const distance = 1.8 // multiplier for how far the camera should be from unit sphere
      const camDist = distance / Math.tan(fov / 2)
      const dir = new THREE.Vector3(2, 1.5, 2).normalize()
      camera.position.copy(dir.multiplyScalar(camDist))
      controls.target.set(0, 0, 0)
      camera.near = 0.01
      camera.far = 1000
      camera.updateProjectionMatrix()
      controls.update()
    }

    files.forEach((file, idx) => {
      loader.load(file, (geometry) => {
        geometry.computeVertexNormals()
        const material = new THREE.MeshStandardMaterial({ color: palette[idx % palette.length], metalness: 0.2, roughness: 0.6 })
        const mesh = new THREE.Mesh(geometry, material)
        group.add(mesh)
        loaded++
        if (loaded === files.length) onLoaded()
      })
    })

    const onResize = () => {
      if (!mountRef.current) return
      const w = mountRef.current.clientWidth
      const hh = h
      renderer.setSize(w, hh)
      camera.aspect = w / hh
      camera.updateProjectionMatrix()
    }
    window.addEventListener('resize', onResize)

    let raf = 0
    const animate = () => {
      controls.update()
      renderer.render(scene, camera)
      raf = requestAnimationFrame(animate)
    }
    animate()

    return () => {
      cancelAnimationFrame(raf)
      window.removeEventListener('resize', onResize)
      renderer.dispose()
      mountRef.current?.removeChild(renderer.domElement)
    }
  }, [src, srcs, height])

  return <div className={className ? className : ''} style={{ width: '100%', height }} ref={mountRef} />
}

